# Maze

### GA WDI London - Project 1

#### A path finding game

This game involves a user travelling across a grid from the north-western most corner to the south-eastern most corner. There is only one correct way across the grid, as defined by a random path generated by the computer.

[Play Maze here.](https://freemaze.herokuapp.com/)



![alt text](./images/Desktopscreenshot.png)



##### Rules

- User begins with 10 lives and must find the way to the south-eastern most corner of the grid.
- The user can only move down (south) or across (east), using either the keys or clicks.
- If the square moved to is correct, the user can continue.
- If the square moved to is incorrect, the user loses a life and is returned to the start.
- If the end is reached, the user scores a point.
- If a score of three is reached, the user gains a life.
- If the user loses all their lives, the game is over. 
- A hint, that reveals the correct path for a fractionof a second, is available to the user at the cost of a life. 
- If the user only has one life remaining, the hint option is disabled.



![alt text](./images/Desktopscreenshot2.png)



##### How it works

The page loads with a 3x3 grid loaded as standard. Selection of a different level causes a new grid to be created dynamically.
A random path across the grid, from the north-western most corner to the south-eastern most corner, is generated by the computer. This works by modelling the grid on the screen as an array of nested arrays. The computer randomly decides to move across the grid (to the next element in the next nested array) or down the grid (to the equivalent element in the next nested array). This move is stored in a variable and executed unless a boundary condition isn't satisfied, for example the edge of the grid has been reached.
A new path is generated every time a grid is created. The squares used in the random path are pushed to an array.
The user inputs a move by either using the arrow keys or mouse clicks. This is stored in a variable and then pushed to an array. Its value triggers the movement of the cursor inside the grid.
After each move, the user move array is compared to the random path array. If the elements agree the move is correct and the user can continue. If the elements disagree, the move is incorrect and the user is returned to the start and the user move array reset.

#### The build

- HTML5, CSS, Javascript and the jQuery library were used to create this game.
- Animations were created using the Animate.css stylesheet.
- The Google Web Fonts 'Lato' and 'Raleway' were used in the styling of the game.

#### Approach

1. After the initial idea was concieved and developed using a sketchbook and notations, the first step was to create the random path generating algorithm. This was key as the whole concept of the game relied upon it. 
At first a tree structure approach to the problem was taken, with N,E,S and W moves possible. Without a weighting applied to any of these directions, an overall direction to the path could not be achieved. As squares could also be revisited, the path did not have a definite length. It was decided to add the boundary conditions that previously used squares could not be revisted. As there was still no direction weighting, this led to a number of closed loops within the grid. To solve these problems the possible moves were restricted to E and S only. Modelling the grid as an array, these conditions allowed an algorithm to be constructed that generated multiple unique paths across square grids of any size.
2. HTML and basic styling created were written alongside further basic functionality in javascript using the jQuery library.
3. Reset and hint functions were added before a first iteration of CSS styling was completed. The design was planned once again using sketches and notations.
4. Use of the arrow keys was added as functionality to aid play on the desktop. Clicks would be re-added alongside this later so that the game could be played on mobile devices.
5. A responsive design was planned and sketched and developd through multiple iterations and testing using Chrome's simulator.

#### Main challlenges

The main challenge faced in the creation of this game was the generation of the random paths. The random path needed to have direction, not visit previously used squares and be one of many possible routes across the grid.
The decision to limit the possible moves from north, east, south and west to south and west only, easily gave direction and removed the possibility of closed loop paths being produced. Multiple unique random paths could still be generated despite this simplification and certainly enough for the requirements of this game.
Number of unique paths possible (as determined by the binomial coefficient):
..- 3x3 grid: 6
..- 4x4 grid: 20
..- 5x5 grid: 70
..- 6x6 grid: 252
I am pleased with the solution I came up with as the it is clean, simple and applicable to square grids of any dimension.

Away from the javascript, another challenge was making the game mobile friendly. A number of layout iterations were tested until designs that worked well on desktop and mobile browsers were found. Media queries were used to achieve the desired responsiveness.



![alt text](./images/Mobilescreenshot.png)
